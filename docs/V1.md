# Obsidian Agent - V1.0 Specification

## V0.01 Goal
Transform the MVP into "Obsidian Agent" - a vault-aware AI assistant with persistent conversations. The agent gains awareness of the Obsidian vault and can search through files (read-only), while conversations persist across sessions using LangGraph's stateful agent framework.

## Scope: What's In

### Core Features
1. **Vault Awareness (Read-Only)**
   - Agent knows it is "Obsidian Agent"
   - Can read files from the vault
   - Can search through vault contents
   - Understands vault structure (folders, files, links)
   - Can reference and quote from notes

2. **Conversation Persistence (LangGraph)**
   - Save and restore conversations between sessions
   - Multiple conversation threads with thread management
   - State persistence using LangGraph checkpointers
   - Conversation history maintained across app restarts
   - Thread-based memory for context retention

### Secondary Features
- **Conversation Management**: Rename, delete, and organize conversations
- **Vault Search Tools**: Search by filename, content, tags
- **File Reading**: Read individual notes or multiple notes
- **Basic Context Display**: Show which files are being referenced
- **Code Highlighting**: Proper syntax highlighting for code blocks
- **Export Conversations**: Save conversations as notes in the vault

## Scope: What's Out (Future Phases)
- File write/update operations (V2.0)
- Active note integration (V2.0)
- File creation/modification (V2.0)
- Automatic context selection (V2.0)
- Semantic search (V3.0)
- Agentic workflows beyond conversation (V4.0)
- Image/attachment support (V2.0+)
- Streaming responses (V1.1 or later)
- Advanced vault manipulation (V2.0+)

## User Stories

### As a user, I want to...

#### Vault Awareness & Search
1. Ask the agent questions about notes in my vault
2. Have the agent search through my vault to find relevant information
3. Ask "What notes do I have about [topic]?" and get accurate results
4. Have the agent read and reference specific notes when answering questions
5. Ask about vault structure ("What's in my Projects folder?")
6. Have the agent understand Obsidian links between notes

#### Conversation Persistence
7. Have my conversations automatically saved when I close Obsidian
8. See my previous conversations when I reopen the plugin
9. Continue a conversation from where I left off days later
10. Have the agent remember context from earlier in the conversation

#### Multiple Conversations
11. Create a new conversation while keeping old ones
12. Switch between different conversation threads
13. See a list of all my conversations with preview text
14. Have separate conversation contexts (one for work, one for personal)

#### Agent Identity & Capabilities
15. Know that I'm talking to "Obsidian Agent"
16. Understand what the agent can and cannot do with my vault
17. Have the agent explain its vault access capabilities
18. Feel confident the agent won't modify my notes (read-only mode)

#### Conversation Management
19. Rename conversations to meaningful titles
20. Delete conversations I no longer need
21. Export a conversation as a markdown note in my vault
22. See which files the agent has accessed during the conversation

## Technical Specification

### Plugin Structure
```
obsidian-agent-across/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.ts                    # Plugin entry point
â”‚   â”œâ”€â”€ views/
â”‚   â”‚   â”œâ”€â”€ ChatView.ts            # Main chat interface
â”‚   â”‚   â”œâ”€â”€ ConversationList.ts    # Conversation sidebar/list
â”‚   â”‚   â””â”€â”€ components/            # Reusable UI components
â”‚   â”œâ”€â”€ agent/
â”‚   â”‚   â”œâ”€â”€ AgentGraph.ts          # LangGraph agent definition
â”‚   â”‚   â”œâ”€â”€ AgentState.ts          # State schema for agent
â”‚   â”‚   â”œâ”€â”€ AgentTools.ts          # Vault access tools
â”‚   â”‚   â””â”€â”€ AgentPrompts.ts        # System prompts and identity
â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”œâ”€â”€ VaultService.ts        # NEW: Vault read operations
â”‚   â”‚   â”œâ”€â”€ ConversationService.ts # Thread/conversation management
â”‚   â”‚   â””â”€â”€ CheckpointService.ts   # NEW: LangGraph checkpoint storage
â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â”œâ”€â”€ Conversation.ts        # Conversation/thread model
â”‚   â”‚   â””â”€â”€ Message.ts             # Message model
â”‚   â”œâ”€â”€ utils/
â”‚   â”‚   â”œâ”€â”€ markdown.ts            # Markdown rendering utilities
â”‚   â”‚   â”œâ”€â”€ export.ts              # Export functionality
â”‚   â”‚   â”œâ”€â”€ vaultSearch.ts         # NEW: Vault search utilities
â”‚   â”‚   â””â”€â”€ linkParser.ts          # NEW: Parse Obsidian links
â”‚   â”œâ”€â”€ types.ts                   # TypeScript interfaces
â”‚   â””â”€â”€ settings.ts                # Settings tab
â”œâ”€â”€ styles.css                     # Plugin styles
â”œâ”€â”€ manifest.json                  # Plugin metadata
â”œâ”€â”€ package.json                   # NEW: Includes LangGraph dependencies
â””â”€â”€ ...
```

### Key Dependencies
```json
{
  "dependencies": {
    "@anthropic-ai/sdk": "^0.32.1",
    "@langchain/langgraph": "^0.2.0",
    "@langchain/langgraph-checkpoint": "^0.0.11",
    "@langchain/core": "^0.3.0",
    "@langchain/anthropic": "^0.3.0",
    "obsidian": "latest",
    "zod": "^3.22.0"
  }
}
```

### Core Components

#### 1. LangGraph Agent State
```typescript
import { Annotation } from "@langchain/langgraph";
import { BaseMessage } from "@langchain/core/messages";

// Define the agent state schema
const AgentState = Annotation.Root({
  messages: Annotation<BaseMessage[]>({
    reducer: (x, y) => x.concat(y),  // Accumulate messages
  }),
  vaultContext: Annotation<string[]>({
    reducer: (x, y) => [...new Set([...x, ...y])],  // Unique file paths
    default: () => [],
  }),
});

interface Conversation {
  threadId: string;              // LangGraph thread ID
  title: string;                 // User-defined title
  createdAt: number;             // Timestamp
  updatedAt: number;             // Timestamp
  metadata?: {
    tags?: string[];
    pinned?: boolean;
    fileCount?: number;          // Files accessed
  };
}
```

#### 2. Vault Service (Read-Only)
**Responsibilities:**
- Read files from vault
- Search vault contents
- Parse Obsidian links
- List vault structure

**Key Methods:**
```typescript
class VaultService {
  // File reading
  async readFile(path: string): Promise<string>
  async readMultipleFiles(paths: string[]): Promise<Record<string, string>>

  // Search operations
  async searchByFilename(query: string): Promise<string[]>
  async searchByContent(query: string): Promise<Array<{path: string, matches: string[]}>>
  async searchByTag(tag: string): Promise<string[]>

  // Vault structure
  async listFiles(folder?: string): Promise<string[]>
  async getFolderStructure(folder?: string): Promise<VaultTree>

  // Metadata
  async getFileMetadata(path: string): Promise<FileMetadata>
  async getBacklinks(path: string): Promise<string[]>
  async getOutgoingLinks(path: string): Promise<string[]>
}
```

#### 3. Agent Tools (LangGraph Tools)
**Vault Access Tools for the Agent:**

```typescript
import { tool } from "@langchain/core/tools";
import { z } from "zod";

// Tool 1: Search vault by filename
const searchVaultByName = tool(
  async (input: { query: string }) => {
    const results = await vaultService.searchByFilename(input.query);
    return `Found ${results.length} files matching "${input.query}":\n${results.join('\n')}`;
  },
  {
    name: "search_vault_by_name",
    description: "Search for files in the vault by filename or partial filename match",
    schema: z.object({
      query: z.string().describe("The filename or partial filename to search for"),
    }),
  }
);

// Tool 2: Search vault by content
const searchVaultByContent = tool(
  async (input: { query: string }) => {
    const results = await vaultService.searchByContent(input.query);
    return formatSearchResults(results);
  },
  {
    name: "search_vault_by_content",
    description: "Search through the content of all notes in the vault",
    schema: z.object({
      query: z.string().describe("The text to search for within notes"),
    }),
  }
);

// Tool 3: Read file
const readVaultFile = tool(
  async (input: { path: string }) => {
    const content = await vaultService.readFile(input.path);
    return `Content of ${input.path}:\n\n${content}`;
  },
  {
    name: "read_vault_file",
    description: "Read the complete contents of a specific file from the vault",
    schema: z.object({
      path: z.string().describe("The full path to the file to read"),
    }),
  }
);

// Tool 4: List vault files
const listVaultFiles = tool(
  async (input: { folder?: string }) => {
    const files = await vaultService.listFiles(input.folder);
    return `Files in ${input.folder || 'vault'}:\n${files.join('\n')}`;
  },
  {
    name: "list_vault_files",
    description: "List all files in the vault or in a specific folder",
    schema: z.object({
      folder: z.string().optional().describe("Optional folder path to list files from"),
    }),
  }
);

const vaultTools = [
  searchVaultByName,
  searchVaultByContent,
  readVaultFile,
  listVaultFiles,
];
```

#### 4. LangGraph Agent Definition
```typescript
import { StateGraph, START, END } from "@langchain/langgraph";
import { ToolNode } from "@langchain/langgraph/prebuilt";
import { ChatAnthropic } from "@langchain/anthropic";
import { MemorySaver } from "@langchain/langgraph-checkpoint";

// Initialize the LLM
const model = new ChatAnthropic({
  model: "claude-3-5-sonnet-20241022",
  apiKey: settings.apiKey,
});

// Bind tools to the model
const boundModel = model.bindTools(vaultTools);

// Create tool node
const toolNode = new ToolNode<typeof AgentState.State>(vaultTools);

// Define agent logic
async function callAgent(state: typeof AgentState.State) {
  // Add system message with agent identity
  const systemMessage = {
    role: "system",
    content: AGENT_SYSTEM_PROMPT,  // "You are Obsidian Agent..."
  };

  const messages = [systemMessage, ...state.messages];
  const response = await boundModel.invoke(messages);

  return { messages: [response] };
}

// Routing logic
function shouldContinue(state: typeof AgentState.State): "tools" | typeof END {
  const lastMessage = state.messages[state.messages.length - 1];
  if (lastMessage && !(lastMessage as AIMessage).tool_calls?.length) {
    return END;
  }
  return "tools";
}

// Build the graph
const workflow = new StateGraph(AgentState)
  .addNode("agent", callAgent)
  .addNode("tools", toolNode)
  .addEdge(START, "agent")
  .addConditionalEdges("agent", shouldContinue)
  .addEdge("tools", "agent");

// Compile with checkpointer
const checkpointer = new MemorySaver();
const agent = workflow.compile({ checkpointer });
```

#### 5. Checkpoint Service
**Responsibilities:**
- Store LangGraph checkpoints to disk
- Load checkpoints on startup
- Manage thread persistence

**Storage Location:**
```
.obsidian/plugins/obsidian-agent-across/
â”œâ”€â”€ checkpoints/
â”‚   â”œâ”€â”€ {thread-id-1}/          # Thread-specific checkpoints
â”‚   â”‚   â”œâ”€â”€ checkpoint-1.json
â”‚   â”‚   â””â”€â”€ checkpoint-2.json
â”‚   â””â”€â”€ {thread-id-2}/
â”œâ”€â”€ conversations.json           # Thread metadata
â””â”€â”€ settings.json
```

**Key Methods:**
```typescript
class CheckpointService {
  // Implements LangGraph checkpointer interface
  async get(config: RunnableConfig): Promise<Checkpoint | undefined>
  async put(config: RunnableConfig, checkpoint: Checkpoint): Promise<void>
  async list(config: RunnableConfig): Promise<CheckpointTuple[]>

  // Thread management
  async createThread(title?: string): Promise<string>
  async getThread(threadId: string): Promise<Conversation>
  async deleteThread(threadId: string): Promise<void>
  async listThreads(): Promise<Conversation[]>
}
```

#### 6. Agent System Prompt

**Agent Identity and Capabilities:**

```typescript
const AGENT_SYSTEM_PROMPT = `You are Obsidian Agent, an AI assistant integrated into Obsidian.

CAPABILITIES:
- You have READ-ONLY access to the user's Obsidian vault
- You can search for files by name, content, and tags
- You can read the contents of any note in the vault
- You can list files and understand the vault structure
- You can see links between notes and backlinks

LIMITATIONS:
- You CANNOT create, modify, or delete files (read-only mode)
- You CANNOT execute any vault modifications
- If asked to create or modify notes, politely explain this will be available in V2.0

BEHAVIOR:
- When users ask about their notes, proactively use your vault search tools
- Quote relevant passages from notes when answering questions
- Reference specific files by name when providing information
- Be transparent about which files you've accessed
- Help users discover connections in their knowledge base

CONTEXT:
- You maintain conversation history across sessions
- You can reference earlier parts of the conversation
- Track which files have been accessed in this conversation
`;
```

#### 7. Enhanced Chat View
**New Features:**
- Conversation switcher in header
- Better message rendering with code highlighting
- Token usage display
- Loading states and animations
- Error boundaries

**UI Elements:**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ [â‰¡] Current Conversation    [+][âš™] â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                     â”‚
â”‚ [User Message]                      â”‚
â”‚ 2 tokens â€¢ 2:30 PM                  â”‚
â”‚                                     â”‚
â”‚     [Assistant Response]            â”‚
â”‚     ```python                       â”‚
â”‚     # Code with syntax highlighting â”‚
â”‚     ```                             â”‚
â”‚     45 tokens â€¢ 2:31 PM             â”‚
â”‚                                     â”‚
â”‚         â†“ (scrollable)              â”‚
â”‚                                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Total: 47 tokens (~$0.001)          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ Type a message...               â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚              [Send] [Export] [New]  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### 5. Conversation List View
**New Component:**
- Sidebar or modal showing all conversations
- Search/filter functionality
- Preview of last message
- Metadata display (date, messages, tokens)

**UI Layout:**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Conversations        [Ã—][+] â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ [Search conversations...]   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ðŸ“Œ Pinned Project           â”‚
â”‚   "Let me help with..."     â”‚
â”‚   5 messages â€¢ 230 tokens   â”‚
â”‚   Today at 2:30 PM          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ â— Research Ideas            â”‚
â”‚   "Here are some..."        â”‚
â”‚   12 messages â€¢ 890 tokens  â”‚
â”‚   Yesterday                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Code Review Discussion      â”‚
â”‚   "The function looks..."   â”‚
â”‚   8 messages â€¢ 450 tokens   â”‚
â”‚   Oct 28, 2024              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Features Detail

#### 1. Conversation Persistence
- Auto-save after each message exchange
- Debounced saving to prevent excessive disk writes
- Background save with error handling
- Data validation on load

#### 2. Multiple Conversations
- Quick conversation switcher in header
- "New Conversation" button/command
- Conversation list view (command palette + UI)
- Active conversation indicator

#### 3. Conversation Management
- Rename via context menu or inline edit
- Delete with confirmation dialog
- Bulk actions (future enhancement)
- Auto-generated titles from first message

#### 4. Code Highlighting
- Integration with Prism.js or similar
- Support for common languages
- Copy code block button
- Language detection

#### 5. Token Tracking
- Count tokens per message (approximate)
- Display total conversation tokens
- Show cost estimate (based on Claude pricing)
- Warning when approaching limits

#### 6. Export Functionality
**Export Formats:**
- Markdown note in vault
- Plain text to clipboard
- JSON (for backup/sharing)

**Export Template:**
```markdown
# [Conversation Title]

**Created**: [Date]
**Messages**: [Count]
**Tokens**: [Total]

---

## Message 1
**User** â€¢ [Timestamp]

[Message content]

## Message 2
**Assistant** â€¢ [Timestamp]

[Message content]

[...]
```

#### 7. Keyboard Shortcuts
| Shortcut | Action |
|----------|--------|
| `Cmd/Ctrl+Enter` | Send message |
| `Cmd/Ctrl+N` | New conversation |
| `Cmd/Ctrl+K` | Open conversation list |
| `Cmd/Ctrl+/` | Toggle chat view |
| `Escape` | Clear input |
| `Cmd/Ctrl+E` | Export conversation |

### Settings Enhancements

```typescript
interface PluginSettings {
  apiKey: string;

  // New settings
  model: string;                        // Model selection
  maxTokens: number;                    // Response length limit
  temperature: number;                  // Response randomness

  autoSaveInterval: number;             // Auto-save delay (ms)
  showTokenCount: boolean;              // Display token usage
  enableCodeHighlighting: boolean;      // Syntax highlighting

  conversationListView: 'sidebar' | 'modal';  // UI preference
  defaultConversationTitle: string;     // Template for new convos

  exportLocation: string;               // Vault folder for exports
  exportTemplate: string;               // Custom export template
}
```

### Data Flow

#### Creating New Conversation
```
User clicks "New"
â†’ ConversationService.createConversation()
â†’ Generate UUID, initialize empty messages[]
â†’ StorageService.saveConversation()
â†’ Update UI, switch to new conversation
```

#### Sending Message
```
User sends message
â†’ Add to current conversation
â†’ ChatService.sendMessage()
â†’ Receive response
â†’ Add response to conversation
â†’ Update token counts
â†’ StorageService.saveConversation() (debounced)
â†’ Update UI
```

#### Switching Conversations
```
User selects conversation from list
â†’ Load conversation from storage/cache
â†’ Update ChatView with messages
â†’ Mark as active conversation
â†’ Update UI
```

#### Exporting Conversation
```
User clicks "Export"
â†’ ConversationService.exportConversation()
â†’ Format as markdown
â†’ Create note in vault (or copy to clipboard)
â†’ Show success notification
```

### Error Handling

#### Storage Errors
- Corrupted conversation file: Skip and log error
- Disk full: Show error, prevent new conversations
- Permission denied: Alert user with instructions

#### Migration
- Detect version changes
- Migrate data format if needed
- Backup before migration
- Rollback on failure

### Performance Considerations

#### Optimization Strategies
- Lazy load conversations (load metadata first)
- Virtual scrolling for long message lists
- Debounced auto-save (500ms delay)
- Cache active conversation in memory
- Paginate conversation list for large libraries

#### Memory Management
- Unload inactive conversations
- Limit in-memory conversation count
- Clear old message cache periodically

### Testing Strategy

#### Manual Testing Checklist
- [ ] Create new conversation
- [ ] Send messages and receive responses
- [ ] Switch between conversations
- [ ] Rename conversation
- [ ] Delete conversation
- [ ] Export conversation to vault
- [ ] Copy message to clipboard
- [ ] Plugin reload preserves conversations
- [ ] Token counting is accurate
- [ ] Code highlighting works for multiple languages
- [ ] Keyboard shortcuts function correctly
- [ ] Settings changes apply immediately
- [ ] Error states display properly
- [ ] Large conversations load quickly
- [ ] Works across Obsidian restarts

#### Edge Cases
- [ ] Empty conversation title
- [ ] Very long messages (>10k chars)
- [ ] Many conversations (>100)
- [ ] Conversation with >1000 messages
- [ ] Rapid message sending
- [ ] Network interruption during send
- [ ] Corrupted conversation file
- [ ] Vault folder doesn't exist (export)

## Implementation Steps

### Phase 1: LangGraph Integration & Setup (Week 1)
1. Install LangGraph dependencies (@langchain/langgraph, @langchain/anthropic, @langchain/core)
2. Create basic agent state schema
3. Implement MemorySaver checkpointer for in-memory testing
4. Build simple LangGraph agent with one test tool
5. Verify agent persistence across invocations

### Phase 2: Vault Service & Tools (Week 1-2)
1. Implement VaultService for read-only operations
   - File reading
   - Search by filename/content/tags
   - List files and folders
2. Create LangGraph tools for vault access
   - search_vault_by_name
   - search_vault_by_content
   - read_vault_file
   - list_vault_files
3. Integrate tools with agent
4. Test tool execution and responses

### Phase 3: Persistent Checkpointing (Week 2)
1. Design checkpoint storage format
2. Implement CheckpointService with disk persistence
3. Create custom checkpointer implementing LangGraph interface
4. Migrate from MemorySaver to persistent checkpointer
5. Test conversation persistence across plugin reloads

### Phase 4: Thread Management & UI (Week 2-3)
1. Implement conversation/thread management
   - Create, list, delete threads
   - Store thread metadata (title, dates, etc.)
2. Update ChatView to support thread switching
3. Build conversation list UI
4. Add thread rename functionality
5. Implement "New Conversation" flow

### Phase 5: Agent Identity & Polish (Week 3)
1. Define agent system prompt with identity
2. Add vault context tracking to UI
3. Implement code syntax highlighting
4. Add export conversation feature
5. Polish error handling and loading states

### Phase 6: Testing & Documentation (Week 3-4)
1. Test vault operations with various vault sizes
2. Test conversation persistence and recovery
3. Test agent tool usage and responses
4. Write user documentation
5. Create developer documentation for LangGraph setup

## Success Criteria

### Functional Requirements
- âœ“ Agent identifies as "Obsidian Agent"
- âœ“ Agent can search vault by filename, content, and tags
- âœ“ Agent can read files from vault
- âœ“ Agent can list vault structure
- âœ“ Conversations persist across sessions using LangGraph checkpoints
- âœ“ Users can create and manage multiple conversation threads
- âœ“ Users can rename and delete threads
- âœ“ Thread history maintained correctly
- âœ“ Code blocks have syntax highlighting
- âœ“ Conversations can be exported to vault

### Non-Functional Requirements
- âœ“ Plugin loads in < 3 seconds
- âœ“ Vault search completes in < 2 seconds for vaults up to 1000 notes
- âœ“ Thread switching is instant (<200ms)
- âœ“ No UI freezing during vault operations
- âœ“ Data integrity maintained across crashes
- âœ“ Works efficiently with conversations up to 100 messages

### Agent Behavior
- âœ“ Agent proactively uses vault tools when appropriate
- âœ“ Agent accurately quotes from vault files
- âœ“ Agent explains read-only limitations when asked to modify
- âœ“ Agent maintains context across conversation
- âœ“ Agent provides helpful responses about vault structure

### User Experience
- âœ“ Clear indication when agent is accessing vault
- âœ“ Intuitive thread management
- âœ“ Helpful error messages for vault operations
- âœ“ Smooth agent responses
- âœ“ Responsive UI on all platforms

## Future Enhancements (Post-V1)

These will be considered for V1.1 or V2.0:
1. **File Write Operations** (V2.0) - Create, update, and delete notes
2. **Active Note Integration** (V2.0) - Automatic context from open note
3. **Streaming Responses** (V1.1) - Faster perceived performance
4. **Automatic Title Generation** (V1.1) - From first message
5. **Advanced Search** - Regex support, search within date ranges
6. **Vault Graph Awareness** (V2.0) - Understand note connections
7. **Conversation Tags** (V1.1) - Organize threads with tags
8. **Multi-file Context** - Read multiple related files at once
9. **Search Result Previews** - Show snippets before reading full file
10. **Conversation Branching** (V2.0) - Fork conversation threads

## Documentation

### User-Facing Documentation
- Introduction to Obsidian Agent
- Guide to vault search capabilities
- Understanding read-only mode
- Tutorial for conversation/thread management
- Export feature guide
- FAQ about agent capabilities and limitations

### Developer Documentation
- LangGraph integration guide
- Agent state schema documentation
- Checkpoint storage format
- Vault service API reference
- Tool implementation guide
- Testing LangGraph agents

## Risks & Mitigations

| Risk | Impact | Mitigation |
|------|--------|------------|
| LangGraph learning curve | High | Thorough docs research, examples, prototyping |
| Checkpoint data loss | Critical | Atomic writes, backups, data validation |
| Vault read performance | High | Caching, lazy loading, search optimization |
| Agent tool reliability | High | Comprehensive testing, error handling |
| Thread state management | Medium | LangGraph handles it, but test thoroughly |
| Large vault performance | High | Implement search limits, pagination |
| Migration failures | High | Backup before migration, rollback capability |

## Definition of Done

- [ ] All functional requirements met
- [ ] All success criteria achieved
- [ ] Agent successfully uses vault tools
- [ ] Conversations persist correctly using LangGraph
- [ ] No critical or high-priority bugs
- [ ] Performance targets met
- [ ] Vault read operations tested with real vaults (100-1000 notes)
- [ ] Documentation complete (user + developer)
- [ ] Migration path from MVP tested
- [ ] User acceptance testing completed
- [ ] Ready for community plugin update

## Timeline Estimate

**Total: 3-4 weeks**

- Week 1: LangGraph setup, basic agent, vault service foundation
- Week 2: Vault tools integration, persistent checkpointing
- Week 3: Thread management UI, agent identity, polish
- Week 4: Testing, documentation, bug fixes, migration

## Metrics for Success

### Quantitative
- 80%+ of MVP users upgrade to V1
- Average 10+ vault searches per active user per week
- Agent successfully accesses vault in 90%+ of relevant queries
- <1% checkpoint corruption issues
- <2 seconds for vault search operations
- 80%+ user satisfaction with vault integration

### Qualitative
- Positive user feedback on vault awareness
- Users report agent is helpful for finding information in notes
- Users feel confident in read-only mode
- Community excited about V2.0 write capabilities
- Developer feedback on LangGraph integration

---

**Note**: V1.0 ("Obsidian Agent") transforms the plugin into a vault-aware AI assistant with persistent conversations using LangGraph. This establishes the foundation for file operations in V2.0 and advanced agentic workflows in future versions.

---

## Work Breakdown Structure

### Overview
V1 development is organized into 6 major work blocks, each building on the previous. This structure allows for incremental development and testing while maintaining a clear path to the final deliverable.

### Block 1: LangGraph Foundation (Week 1) âœ… COMPLETE
**Goal**: Get a basic LangGraph agent working with in-memory persistence

**Tasks**:
1. âœ… Install dependencies
   - Added `@langchain/langgraph@^1.0.1`, `@langchain/core@^1.0.2`, `zod@^3.24.1`
   - Updated `package.json` and verified builds
   - Fixed esbuild config to externalize `node:async_hooks`
2. âœ… Create agent state schema
   - Created `src/agent/AgentState.ts` with `AgentState` definition
   - Defined messages array with accumulation reducer
   - Added `vaultContext` tracking for future vault operations
3. âœ… Build minimal agent
   - Created `src/agent/AgentGraph.ts` with `ObsidianAgent` class
   - Implemented agent graph (agent node â†’ tool node â†’ agent)
   - Used `MemorySaver` for in-memory checkpointing
   - Created echo test tool for validation
   - Used Anthropic SDK directly (claude-3-5-sonnet-20241022)
4. âœ… Test persistence
   - Agent uses thread IDs for conversation separation
   - MemorySaver maintains context across invocations
5. âœ… Integrate with ChatView
   - Updated `src/ChatView.ts` to use `ObsidianAgent`
   - Replaced `ChatService` with agent
   - Added thread ID support (`threadId: 'default-thread'`)
   - Changed display text to "Obsidian Agent"

**Deliverable**: Working chat interface with LangGraph agent that maintains conversation context in memory

**Implementation Notes**:
- Used Anthropic SDK directly instead of `@langchain/anthropic` due to version conflicts
- Updated `tsconfig.json` moduleResolution to `"bundler"` for proper imports
- System prompt defines agent identity as "Obsidian Agent" with read-only vault capabilities

**Testing Instructions**:
To test Block 1 completion, follow these steps in Obsidian:

1. **Plugin Setup**:
   - Copy the built `main.js` to your test vault: `.obsidian/plugins/obsidian-agent/`
   - Copy `manifest.json` and `styles.css` to the same location
   - Reload Obsidian or enable the plugin in Community Plugins settings

2. **Configure API Key**:
   - Open plugin settings
   - Enter your Anthropic API key
   - Save settings

3. **Test Basic Functionality**:
   - [ ] Open the "Obsidian Agent" view from the left sidebar
   - [ ] Send a test message (e.g., "Hello!")
   - [ ] Verify you receive a response from Claude
   - [ ] Send a follow-up message referencing the first (e.g., "What did I just say?")
   - [ ] Verify the agent maintains conversation context

4. **Test Persistence (Within Session)**:
   - [ ] Send a few messages back and forth
   - [ ] Close and reopen the Obsidian Agent view (keep Obsidian open)
   - [ ] Note: Context is lost because we're using in-memory MemorySaver (expected behavior for Block 1)
   - [ ] This will be fixed in Block 4 with disk-based persistence

5. **Test Error Handling**:
   - [ ] Try sending a message without an API key configured
   - [ ] Verify you see a helpful error message
   - [ ] Configure API key and retry

6. **Check Console**:
   - [ ] Open Developer Tools (Ctrl/Cmd + Shift + I)
   - [ ] Check for any errors in the console
   - [ ] Verify no critical errors appear during normal operation

**Known Limitations (Block 1)**:
- Conversations do NOT persist across plugin reloads or Obsidian restarts (uses MemorySaver)
- Agent does not have vault access yet (placeholder tools only)
- Single conversation thread ("default-thread")
- No thread management UI

**Validation**:
- âœ… Agent responds to messages
- âœ… Conversation context persists within session
- âœ… Thread ID infrastructure in place (using "default-thread")
- âœ… No build errors
- â³ Manual testing in Obsidian required (user to complete)

---

### Block 2: Vault Service (Read-Only) (Week 1-2)
**Goal**: Build service layer for reading from Obsidian vault

**Tasks**:
1. Create VaultService class
   - Implement `readFile(path: string)`
   - Implement `listFiles(folder?: string)`
   - Handle errors gracefully (file not found, etc.)
2. Implement search operations
   - `searchByFilename(query: string)` - partial match
   - `searchByContent(query: string)` - full-text search
   - `searchByTag(tag: string)` - parse frontmatter/inline tags
3. Add metadata operations
   - `getFileMetadata(path: string)` - frontmatter, stats
   - `getBacklinks(path: string)` - using Obsidian API
   - `getOutgoingLinks(path: string)` - parse `[[]]` links
4. Create utility functions
   - `linkParser.ts` - parse Obsidian link syntax
   - `vaultSearch.ts` - search optimization/caching
5. Write tests
   - Test with sample vault structure
   - Test edge cases (empty files, special characters)

**Deliverable**: VaultService that can read and search the vault

**Validation**:
- [ ] Can read files from vault
- [ ] Search by filename works
- [ ] Content search works
- [ ] Tag search works
- [ ] Handles errors gracefully
- [ ] Performance acceptable on 100+ note vault

---

### Block 3: Vault Tools for Agent (Week 2)
**Goal**: Create LangGraph tools that expose vault operations to the agent

**Tasks**:
1. Design tool schemas
   - Define Zod schemas for each tool
   - Write clear descriptions for agent understanding
2. Implement 4 core tools
   - `search_vault_by_name` - search filenames
   - `search_vault_by_content` - full-text search
   - `read_vault_file` - read complete file
   - `list_vault_files` - list folder contents
3. Tool error handling
   - Return helpful error messages to agent
   - Handle file not found, permission errors
   - Format results for agent consumption
4. Test tools
   - Test each tool independently
   - Test tool responses are agent-friendly
5. Integrate with agent
   - Bind tools to model
   - Create ToolNode with vault tools
   - Test agent can call tools successfully

**Deliverable**: Agent can search and read from vault via tools

**Validation**:
- [ ] Agent successfully calls vault tools
- [ ] Agent receives formatted results
- [ ] Agent can chain multiple tool calls
- [ ] Error messages are clear
- [ ] Tool responses include relevant context

---

### Block 4: Persistent Checkpointing (Week 2-3)
**Goal**: Implement disk-based checkpoint persistence

**Tasks**:
1. Design storage format
   - Define checkpoint JSON structure
   - Define thread metadata structure
   - Plan directory structure (`.obsidian/plugins/obsidian-agent/checkpoints/`)
2. Implement CheckpointService
   - Implement LangGraph checkpointer interface
   - `get(config)` - load checkpoint from disk
   - `put(config, checkpoint)` - save checkpoint to disk
   - `list(config)` - list checkpoints for thread
3. Add thread management
   - `createThread(title?)` - generate thread ID, create metadata
   - `getThread(threadId)` - load thread metadata
   - `deleteThread(threadId)` - remove thread and checkpoints
   - `listThreads()` - get all thread metadata
4. Handle data integrity
   - Atomic writes (write to temp, then rename)
   - Validate checkpoint structure on load
   - Backup before destructive operations
5. Migrate from MemorySaver
   - Replace MemorySaver with CheckpointService
   - Test persistence across plugin reloads
   - Test Obsidian app restarts

**Deliverable**: Conversations persist to disk and survive app restarts

**Validation**:
- [ ] Conversations save to disk
- [ ] Conversations load on plugin startup
- [ ] Can continue conversation after Obsidian restart
- [ ] Multiple threads work correctly
- [ ] No data corruption
- [ ] Performance acceptable (save < 100ms)

---

### Block 5: Thread Management UI (Week 3)
**Goal**: Build UI for creating, switching, and managing conversation threads

**Tasks**:
1. Update conversation model
   - Update `Conversation` interface for threads
   - Add thread ID, creation date, update date
2. Create ConversationService
   - Wrapper around CheckpointService for UI
   - `createConversation(title?)` - create new thread
   - `getConversations()` - list all threads with metadata
   - `renameConversation(id, title)` - update thread title
   - `deleteConversation(id)` - delete thread
3. Build ConversationList component
   - List all conversations
   - Show preview of last message
   - Show metadata (date, message count)
   - Click to switch conversation
4. Update ChatView
   - Add conversation switcher in header
   - Add "New Conversation" button
   - Display current conversation title
   - Allow inline rename
5. Implement export feature
   - Export conversation as markdown note
   - Include metadata (date, participants)
   - Format messages nicely
   - Save to vault

**Deliverable**: Full thread management UI

**Validation**:
- [ ] Can create new conversations
- [ ] Can switch between conversations
- [ ] Can rename conversations
- [ ] Can delete conversations
- [ ] Can export to vault
- [ ] UI updates correctly
- [ ] No data loss when switching

---

### Block 6: Agent Identity & Polish (Week 3-4)
**Goal**: Define agent identity, polish UX, and prepare for release

**Tasks**:
1. Implement agent system prompt
   - Write detailed system prompt (see V1.md)
   - Include identity ("You are Obsidian Agent")
   - Document capabilities and limitations
   - Add tool usage instructions
2. Add UI context indicators
   - Show when agent is accessing vault
   - Display which files agent has read
   - Show tool call activity
   - Add loading states for tool execution
3. Implement code highlighting
   - Add Prism.js or similar
   - Detect code blocks in responses
   - Apply syntax highlighting
4. Polish error handling
   - User-friendly error messages
   - Clear recovery paths
   - Log errors for debugging
5. Performance optimization
   - Cache vault searches
   - Debounce UI updates
   - Optimize checkpoint saves
6. Testing & bug fixes
   - Test with various vault sizes
   - Test edge cases (empty vault, huge files)
   - Fix any discovered bugs
7. Documentation
   - User guide (how to use agent)
   - Developer guide (architecture, extending)
   - Migration guide from MVP

**Deliverable**: Polished, production-ready V1

**Validation**:
- [ ] Agent identity clear in responses
- [ ] Agent correctly uses vault tools
- [ ] Agent explains limitations when asked to write
- [ ] Code highlighting works
- [ ] Error messages helpful
- [ ] Performance smooth (no lag)
- [ ] Documentation complete
- [ ] Ready for users

---

## Dependencies Between Blocks

```
Block 1 (LangGraph Foundation)
    â†“
Block 2 (Vault Service) â† Can start in parallel with Block 1 after day 2
    â†“
Block 3 (Vault Tools)
    â†“
Block 4 (Persistent Checkpointing)
    â†“
Block 5 (Thread Management UI)
    â†“
Block 6 (Agent Identity & Polish)
```

## Critical Path
**Blocks 1 â†’ 3 â†’ 4** are on the critical path. Block 2 can be developed in parallel with Block 1 after the basic agent structure is established. Blocks 5 and 6 build on the foundation but can overlap (e.g., start polish work while finishing UI).

## Estimated Time per Block
- Block 1: 3-4 days
- Block 2: 3-4 days (parallel with Block 1 days 3-4)
- Block 3: 2-3 days
- Block 4: 3-4 days
- Block 5: 3-4 days
- Block 6: 4-5 days

**Total: 18-24 days (3.5-4.5 weeks)**

## Risk Mitigation
- **Block 1**: Start with simple example before full integration
- **Block 2**: Test vault operations thoroughly with edge cases
- **Block 3**: Mock tools first, test agent behavior separately
- **Block 4**: Implement atomic writes, backup mechanism
- **Block 5**: Keep UI simple, focus on core functionality
- **Block 6**: Buffer time for unexpected issues
